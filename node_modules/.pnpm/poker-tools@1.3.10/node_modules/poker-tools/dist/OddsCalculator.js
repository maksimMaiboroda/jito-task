"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Card = require("./Card");

var _Card2 = _interopRequireDefault(_Card);

var _Rank = require("./Rank");

var _Rank2 = _interopRequireDefault(_Rank);

var _Suit = require("./Suit");

var _Suit2 = _interopRequireDefault(_Suit);

var _CardGroup = require("./CardGroup");

var _CardGroup2 = _interopRequireDefault(_CardGroup);

var _HandRank = require("./HandRank");

var _HandRank2 = _interopRequireDefault(_HandRank);

var _HandEquity = require("./HandEquity");

var _HandEquity2 = _interopRequireDefault(_HandEquity);

require("lodash.combinations");

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OddsCalculator = function () {
  function OddsCalculator(equities, handranks, iterations, elapsedTime) {
    _classCallCheck(this, OddsCalculator);

    this.equities = equities;
    this.handranks = handranks;
    this.iterations = iterations;
    this.elapsedTime = elapsedTime;
  }

  _createClass(OddsCalculator, [{
    key: "getIterationCount",
    value: function getIterationCount() {
      return this.iterations;
    }
  }, {
    key: "getElapsedTime",
    value: function getElapsedTime() {
      return this.elapsedTime;
    }
  }, {
    key: "getHandRank",
    value: function getHandRank(index) {
      return this.handranks[index];
    }
  }], [{
    key: "allCombinationsOfSize",
    value: function allCombinationsOfSize(a, used, startIndex, currentSize, k) {
      if (currentSize < k) {
        for (var i = 0; i < a.length; i++) {}
      }
    }
  }, {
    key: "calculateHandrankForOmaha",
    value: function calculateHandrankForOmaha(board, cardgroup) {
      var pocketCombos = _lodash2.default.combinations(cardgroup.getCards(), 2);
      var boardCombos = _lodash2.default.combinations(board.getCards(), 3);

      if (!cardgroup.getCard(0)) {
        return _HandRank2.default.evaluate(cardgroup);
      }

      var highestRank = undefined;
      for (var i = 0; i < pocketCombos.length; i++) {
        var pocketGroup = new _CardGroup2.default(pocketCombos[i]);
        if (boardCombos.length === 0) {
          var handrank = _HandRank2.default.evaluate(pocketGroup);
          if (!highestRank || handrank.compareTo(highestRank) > 0) {
            highestRank = handrank;
          }
        } else {
          for (var j = 0; j < boardCombos.length; j++) {
            var boardGroup = new _CardGroup2.default(boardCombos[j]);
            var _handrank = _HandRank2.default.evaluate(pocketGroup.concat(boardGroup));
            if (!highestRank || _handrank.compareTo(highestRank) > 0) {
              highestRank = _handrank;
            }
          }
        }
      }

      return highestRank;
    }
  }, {
    key: "calculateWinner",
    value: function calculateWinner(cardgroups, board) {
      var isOmaha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var handranks = cardgroups.map(function (cardgroup, i) {
        return {
          index: i,
          handrank: isOmaha ? OddsCalculator.calculateHandrankForOmaha(board, cardgroup) : _HandRank2.default.evaluate(board ? cardgroup.concat(board) : cardgroup)
        };
      });

      handranks.sort(function (a, b) {
        return b.handrank.compareTo(a.handrank);
      });

      var result = [[handranks[0]]];
      for (var i = 1; i < handranks.length; i++) {
        if (handranks[i].handrank.compareTo(result[result.length - 1][0].handrank) === 0) {
          result[result.length - 1].push(handranks[i]);
        } else {
          result.push([handranks[i]]);
        }
      }

      return result;
    }
  }, {
    key: "calculateEquity",
    value: function calculateEquity(cardgroups, board, iterations) {
      if (board && [0, 3, 4, 5].indexOf(board.length()) === -1) {
        throw new Error("The board must contain 0, 3, 4 or 5 cards");
      }

      // Detect duplicate cards
      for (var i = 0; i < cardgroups.length; i++) {
        for (var j = i + 1; j < cardgroups.length; j++) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = cardgroups[j].getCards()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var card = _step.value;

              if (cardgroups[i].containsCard(card)) {
                throw new Error("Detected duplicate cards");
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
      if (board && board.length()) {
        for (var _i = 0; _i < cardgroups.length; _i++) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = cardgroups[_i].getCards()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _card = _step2.value;

              if (board.containsCard(_card)) {
                throw new Error("Detected duplicate cards");
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }

      iterations = iterations || 0;
      var odds = [];
      var handranks = [];
      // Find out which cards are left in the deck
      var remainingCards = new _CardGroup2.default([]);
      if (!board || board.length() <= 4) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _Suit2.default.all()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var suit = _step3.value;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = _Rank2.default.all()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var rank = _step4.value;

                var c = new _Card2.default(rank, suit);
                var isUsed = false;
                if (board) {
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = undefined;

                  try {
                    for (var _iterator5 = board.getCards()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      var boardCard = _step5.value;

                      if (c.equals(boardCard)) {
                        isUsed = true;
                        break;
                      }
                    }
                  } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                      }
                    } finally {
                      if (_didIteratorError5) {
                        throw _iteratorError5;
                      }
                    }
                  }
                }
                if (!isUsed) {
                  var _iteratorNormalCompletion6 = true;
                  var _didIteratorError6 = false;
                  var _iteratorError6 = undefined;

                  try {
                    for (var _iterator6 = cardgroups[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                      var cardgroup = _step6.value;
                      var _iteratorNormalCompletion7 = true;
                      var _didIteratorError7 = false;
                      var _iteratorError7 = undefined;

                      try {
                        for (var _iterator7 = cardgroup.getCards()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                          var _card2 = _step7.value;

                          if (c.equals(_card2)) {
                            isUsed = true;
                            break;
                          }
                        }
                      } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                          }
                        } finally {
                          if (_didIteratorError7) {
                            throw _iteratorError7;
                          }
                        }
                      }

                      if (isUsed) {
                        break;
                      }
                    }
                  } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                      }
                    } finally {
                      if (_didIteratorError6) {
                        throw _iteratorError6;
                      }
                    }
                  }
                }
                if (!isUsed) {
                  remainingCards.push(c);
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var remainingCount = remainingCards.length();
      // Figure out hand ranking
      handranks = cardgroups.map(function (cardgroup) {
        return _HandRank2.default.evaluate(board ? cardgroup.concat(board) : cardgroup);
      });
      var equities = cardgroups.map(function (cardgroup) {
        return new _HandEquity2.default();
      });

      var selectWinners = function selectWinners(simulatedBoard) {
        var highestRanking = null;
        var highestRankingIndex = [];
        for (var _i2 = 0; _i2 < cardgroups.length; _i2++) {
          var handranking = _HandRank2.default.evaluate(cardgroups[_i2].concat(simulatedBoard));
          var isBetter = highestRanking ? handranking.compareTo(highestRanking) : -1;
          if (highestRanking === null || isBetter >= 0) {
            if (isBetter == 0) highestRankingIndex.push(_i2);else highestRankingIndex = [_i2];
            highestRanking = handranking;
          }
        }
        for (var _i3 = 0; _i3 < cardgroups.length; _i3++) {
          var isWinning = false;
          var isTie = false;
          if (highestRankingIndex.length > 1) {
            isTie = highestRankingIndex.indexOf(_i3) > -1;
          } else {
            isWinning = highestRankingIndex.indexOf(_i3) > -1;
          }
          equities[_i3].addPossibility(isWinning, isTie);
        }
      };

      var jobStartedAt = +new Date();
      if (!board || board.length() === 0) {
        iterations = iterations || 100000;
        for (var x = iterations; x > 0; x--) {
          var index1 = _lodash2.default.random(0, remainingCount - 1);
          var index2 = void 0,
              index3 = void 0,
              index4 = void 0,
              index5 = void 0;
          do {
            index2 = _lodash2.default.random(0, remainingCount - 1);
          } while (index2 === index1);
          do {
            index3 = _lodash2.default.random(0, remainingCount - 1);
          } while (index3 === index1 || index3 === index2);
          do {
            index4 = _lodash2.default.random(0, remainingCount - 1);
          } while (index4 === index1 || index4 === index2 || index4 === index3);
          do {
            index5 = _lodash2.default.random(0, remainingCount - 1);
          } while (index5 === index1 || index5 === index2 || index5 === index3 || index5 === index4);
          var simulatedBoard = new _CardGroup2.default([remainingCards.getCard(index1), remainingCards.getCard(index2), remainingCards.getCard(index3), remainingCards.getCard(index4), remainingCards.getCard(index5)]);
          selectWinners(simulatedBoard);
        }
      } else if (board.length() >= 5) {
        iterations = 1;
        selectWinners(board);
      } else if (board.length() === 4) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = remainingCards.getCards()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var _c = _step8.value;

            var _simulatedBoard = board.concat(new _CardGroup2.default([_c]));
            iterations++;
            selectWinners(_simulatedBoard);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      } else if (board.length() === 3) {
        for (var a = 0; a < remainingCount; a++) {
          for (var b = a + 1; b < remainingCount; b++) {
            var highestRanking = null;
            var highestRankingIndex = -1;
            var _simulatedBoard2 = board.concat(new _CardGroup2.default([remainingCards.getCard(a), remainingCards.getCard(b)]));
            iterations++;
            selectWinners(_simulatedBoard2);
          }
        }
      }
      var jobEndedAt = +new Date();
      return new OddsCalculator(equities, handranks, iterations, jobEndedAt - jobStartedAt);
    }
  }]);

  return OddsCalculator;
}();

exports.default = OddsCalculator;